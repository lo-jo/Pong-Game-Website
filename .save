from rest_framework.generics import RetrieveAPIView
from rest_framework import status
from rest_framework.response import Response
from .models import UserProfile, Match, Tournament
from .serializers import UserProfileSerializer, MatchSerializer, TournamentSerializer

class UserProfileView(RetrieveAPIView):
    queryset = UserProfile.objects.all()
    serializer_class = UserProfileSerializer

    def get_object(self):
        id = self.kwargs['pk']
        try:
            return UserProfile.objects.get(pk=id)
        except UserProfile.DoesNotExist:
            return Response(status=status.HTTP_404_NOT_FOUND)

    def get_related_data(self, user_profile):
        # Obtener historial de partidos del usuario
        matches = Match.objects.filter(player=user_profile.user)
        match_serializer = MatchSerializer(matches, many=True)
        
        # Obtener historial de torneos del usuario
        tournaments = Tournament.objects.filter(players=user_profile.user)
        tournament_serializer = TournamentSerializer(tournaments, many=True)
        
        return {
            'user_profile': self.serializer_class(user_profile).data,
            'matches': match_serializer.data,
            'tournaments': tournament_serializer.data
        }

    def retrieve(self, request, *args, **kwargs):
        user_profile = self.get_object()
        data = self.get_related_data(user_profile)
        return Response(data)


# status -> string
# user_1 -> id 
# user_2 -> id
# winner -> id_user 
# loser  -> id_user
# tournament_id -> id_tournoi
# created_at -> time
import os
from django.core.asgi import get_asgi_application
from channels.routing import ProtocolTypeRouter, URLRouter
from channels.security.websocket import AllowedHostsOriginValidator
from channels.auth import AuthMiddlewareStack
from notification.routing import websocket_urlpatterns
from channels.http import AsgiHandler
# Initialize Daphne with SSL support
from daphne.server import Server
from daphne.endpoints import build_ssl_options
from django.urls import path


os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'trs.settings')

application = ProtocolTypeRouter({
    "http": AsgiHandler(),
    "websocket": AllowedHostsOriginValidator(
        AuthMiddlewareStack(
            URLRouter(
                websocket_urlpatterns
            )
        )
    ),
})

private_key_path = '/etc/ssl/private/selfsigned.key'
certificate_path = '/etc/ssl/private/selfsigned.crt'

ssl_options = build_ssl_options({
    "privateKey": private_key_path,
    "certChain": certificate_path,
})


Server(application, endpoint_description=ssl_options).run()

Server(application, endpoint_description=ssl_options).run()


// Define routes
const routes = {
 '/profile/:id': {
    template: 'profile.html', // Assuming you have a template for the profile view
    controller: loadProfile, // Function to load and display the profile
 },
 // Add other routes as needed
};

// Function to load and display a profile
async function loadProfile(id) {
 // Fetch profile data (replace this with your actual data fetching logic)
 const profileData = await fetchProfileData(id);

 // Render the profile view with the fetched data
 renderProfileView(profileData);
}

// Function to handle route changes
function handleRouteChange() {
 const path = window.location.pathname;
 const route = routes[path];

 if (route) {
    const id = path.split('/')[2]; // Extract the profile ID from the URL
    route.controller(id); // Call the controller function with the ID
 } else {
    // Handle unknown routes, e.g., show a 404 page
 }
}

// Listen for popstate events to handle browser back/forward navigation
window.addEventListener('popstate', handleRouteChange);

// Initial route handling
handleRouteChange();

async def game_loop(self):
    players_ready = set()  # Almacena los jugadores que están listos

    while len(players_ready) < 2:
        await asyncio.sleep(1)  # Espera a que los dos jugadores estén listos

    # Ambos jugadores están listos, iniciar el juego
    await self.send_to_group('start_game')

    while True:
        # Tu lógica de juego aquí
        
        # Verificar si algún jugador se ha desconectado
        disconnected_players = set()
        for channel_name in self.channel_layer.group_channels(self.group_name):
            if not await self.channel_layer.send(channel_name, {'type': 'ping'}):
                disconnected_players.add(channel_name)

        # Si algún jugador se ha desconectado, pausa el juego y espera su regreso
        if disconnected_players:
            await self.send_to_group('pause_game')

        # Espera un tiempo antes de verificar de nuevo
        await asyncio.sleep(1)

async def ping(self, event):
    # Este método se usa para comprobar si el cliente está conectado
    # Devuelve True si está conectado, False si no lo está
    await self.send({'type': 'pong'})

async def pong(self, event):
    # Este método se llama cuando el cliente responde al ping
    pass


//////////////////////////////////////////////////////////////////////////////////////////////////////////////


import json
from django.db import transaction
from channels.generic.websocket import AsyncWebsocketConsumer
from .models import Game

class PongConsumer(AsyncWebsocketConsumer):
    async def connect(self):
        self.match_id = self.scope['url_route']['kwargs']['id']
        self.group_name = f'match_{self.match_id}'

        await self.channel_layer.group_add(
            self.group_name,
            self.channel_name
        )
        await self.accept()

        # Verificar si el juego ya está en progreso
        try:
            game = Game.objects.get(match_id=self.match_id)
            if game.timer_started:
                await self.send_to_group(f'time_remaining: {game.time_elapsed} seconds')
        except Game.DoesNotExist:
            pass

        asyncio.create_task(self.game_loop())

    async def disconnect(self, close_code):
        print(f"DISCONNECT  {close_code}")
        await self.channel_layer.group_discard(
            self.group_name,
            self.channel_name
        )

    async def websocket_disconnect(self, close_code):
        await self.send_to_group('someone_left')
        print(f"WEBSOCKET DISCONNECTTTTTTTTTTTT   {close_code}")

    async def receive(self, text_data):
        message = json.loads(text_data)
        print(message)

    async def send_to_group(self, param):
        print(f"send to group {param}")
        await self.channel_layer.group_send(
                self.group_name,
                {
                    'type': 'send_game_state',
                    'game_state': f'{param}',
                    'sender_to' : self.group_name
                }
            )

    async def send_to_connection(self, event):
        await self.send(text_data=json.dumps(event))

    async def send_game_state(self, event):
        await self.send(text_data=json.dumps(event))

    async def game_loop(self):
        players_ready = set()  # Almacena los jugadores que están listos
        game_started = False
        game_duration = 120  # Duración del juego en segundos (2 minutos)

        # Verificar si el juego ya está en progreso
        try:
            game = Game.objects.get(match_id=self.match_id)
            if game.timer_started:
                game_started = True
                time_elapsed = game.time_elapsed
                await self.send_to_group('start_game')
        except Game.DoesNotExist:
            pass

        while len(players_ready) < 2:
            await asyncio.sleep(1)  # Espera a que los dos jugadores estén listos

        if not game_started:
            await self.send_to_group('start_game')
            game_started = True
            time_elapsed = 0

        while time_elapsed < game_duration:
            # Tu lógica de juego aquí

            # Verificar si algún jugador se ha desconectado
            disconnected_players = set()
            for channel_name in self.channel_layer.group_channels(self.group_name):
                if not await self.channel_layer.send(channel_name, {'type': 'ping'}):
                    disconnected_players.add(channel_name)

            # Si algún jugador se ha desconectado, pausa el juego y espera su regreso
            if disconnected_players:
                await self.send_to_group('pause_game')

            # Actualizar el tiempo transcurrido
            time_elapsed += 1

            # Verificar si ha pasado 5 segundos y enviar actualización del tiempo
            if time_elapsed % 5 == 0:
                time_remaining = game_duration - time_elapsed
                await self.send_to_group(f'time_remaining: {time_remaining} seconds')

            await asyncio.sleep(1)  # Espera un segundo antes de continuar el bucle

        # El juego ha terminado
        await self.send_to_group('end_game')

        # Guardar el estado del temporizador en la base de datos
        with transaction.atomic():
            game = Game.objects.select_for_update().get(match_id=self.match_id)
            game.timer_started = False
            game.time_elapsed = 0
            game.save()
